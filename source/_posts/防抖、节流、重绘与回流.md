---
title: 防抖、节流、重绘与回流
date: 2019-06-14 15:05:45
categories: 
- 前端
tags:
-前端
-干货
---

# 写在前面

最近在查漏补缺（其实就是菜），发现一段时间不学习后就会被新的知识所淘汰呢，只有不断地努力学习才能不断地提高自己。

今天我们就来讲一下最近前端的几个新名词：防抖、节流、重绘和回流。虽说是新名词，但并不是新技术。

# 防抖和节流

## 概念（定义）

* **防抖：任务频繁触发的情况下，只有任务触发的间隔超过制定的时间间隔的时候，任务才会被执行。**

* **节流：指定时间间隔内只会执行一次任务。**

## 解释

### 防抖

这里引用了知乎上的一段示例代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>防抖</title>
</head>
<body>
  <button id="debounce">点我防抖！</button>

  <script>
    window.onload = function() {
      // 1、获取这个按钮，并绑定事件
      var myDebounce = document.getElementById("debounce");
      myDebounce.addEventListener("click", debounce(sayDebounce));
    }

    // 2、防抖功能函数，接受传参
    function debounce(fn) {
      // 4、创建一个标记用来存放定时器的返回值
      let timeout = null;
      return function() {
        // 5、每次当用户点击/输入的时候，把前一个定时器清除
        clearTimeout(timeout);
        // 6、然后创建一个新的 setTimeout，
        // 这样就能保证点击按钮后的 interval 间隔内
        // 如果用户还点击了的话，就不会执行 fn 函数
        timeout = setTimeout(() => {
          fn();
        }, 1000);
      };
    }

    // 3、需要进行防抖的事件处理
    function sayDebounce() {
      // ... 有些需要防抖的工作，在这里执行
      console.log("防抖成功！");
    }

  </script>
</body>
</html>
```

我们来理解一下代码：

1. 我们点击页面上的按钮，执行 `debounce`函数，并传入参数`sayDebounce`
2. 在函数`debounce`中返回了一个匿名函数，并在匿名函数中定义了一个定时器。
3. 执行匿名函数时，先清除定时器，然后再创建一个新的定时器。
4. 延时1秒执行传入的函数`sayDebounce()`

程序大致的执行过程已经介绍完了，整个防抖程序的关键就在于第3步中。

为什么这么说呢？

因为，我们每次点击都会去执行匿名函数，匿名函数每次执行前都会去清除一次定时器，然后再重新定义定时器。这样做就会让函数永远都只会在满足定时器制定的时间间隔后才会执行。（可能这样说有点不恰当）。我们改造一下这个`sayDebounce`函数：

``` javascript
function sayDebounce() {
	//console.log("防抖成功！");
	let myDate = new Date();
	let mytime=myDate.toLocaleTimeString();
	console.log(myDate.toLocaleString());
}
```

这样，我们再次执行的时候控制台打印出来的时间永远都是我们最后一次点击的时间加上1秒（不考虑程序执行时间）。

**举个栗子：**

假设，我今天要去抢手机，手机早上11点整开售，我们10点59分50秒进去疯狂点击，但是由于抢购按钮采用了防抖，且时间间隔为1秒，那么无论我们手速多块，一秒点多少次，都是无效的。因为程序根本不会执行到抢购程序那里，所以最好的抢购时机就是10点59分59秒的时候点击，那么11点整的时候正好执行了抢购程序（不考虑程序执行时间）。

### 节流

同样，这里也是引用了知乎的一个示例代码：

``` html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>节流</title>
</head>
<body>

  <button id="throttle">点我节流！</button>

  <script>
    window.onload = function() {
      // 1、获取按钮，绑定点击事件
      var myThrottle = document.getElementById("throttle");
      myThrottle.addEventListener("click", throttle(sayThrottle));
    }

    // 2、节流函数体
    function throttle(fn) {
      // 4、通过闭包保存一个标记
      let canRun = true;
      return function() {
        // 5、在函数开头判断标志是否为 true，不为 true 则中断函数
        if(!canRun) {
          return;
        }
        // 6、将 canRun 设置为 false，防止执行之前再被执行
        canRun = false;
        // 7、定时器
        setTimeout( () => {
          fn();
          // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true
          canRun = true;
        }, 1000);
      };
    }

    // 3、需要节流的事件
    function sayThrottle() {
      console.log("节流成功！");
    }

  </script>
</body>
</html>
```

我们首先来解释一下代码：

1. 我们点击页面上的按钮，执行 `throttle`函数，并传入参数`sayThrottle`
2. 在函数`throttle`中定义了一个bool变量`canRun`，赋值为true；还返回了一个匿名函数。
3. 在执行匿名函数时，先判断`canRun`，若值为false,则`return`，反之赋值`canRun`赋值为false，然后再创建一个定时器。
4. 在定时器中延时1秒执行传入的函数`sayThrottle()`，并将`canRun`的值赋为true。

程序的大致执行过程已经介绍完了，整个节流程序中核心步骤在第3步与第4步中。

每次我们点击按钮，程序都会去执行匿名函数。在执行匿名函数中的定时器之前，程序会先去判断`canRun`的值，若值为false，则直接退出程序。反之才会执行定时器。即，程序第一次执行完之前，该程序是无法继续去执行第二次的。

这就好比你去上厕所，但是厕所只有一个位置，第一个人进去之后，你只能等别人出来之后再进去。（可能不太恰当，理解万岁）

## 区别

* 相同点：都是防止重复触发事件（前端的性能优化）。
* 不同点：从定义上来看，防抖是在点击之后